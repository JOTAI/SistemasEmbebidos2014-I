CCS PCM C Compiler, Version 5.008, 5967               28-jun-14 19:23

               Filename:   D:\IGNACIO\ProgramacionGitHub\SistemasEmbebidos2014-I\PicC\16f877a\TECLADO_CLAVE_PR\Teclavo_Clave.lst

               ROM used:   793 words (10%)
                           Largest free fragment is 2048
               RAM used:   32 (9%) at main() level
                           51 (14%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   2F1
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.5
001A:  GOTO   01D
001B:  BTFSC  0C.5
001C:  GOTO   02E
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   20,W
0028:  MOVWF  0A
0029:  SWAPF  21,W
002A:  MOVWF  03
002B:  SWAPF  7F,F
002C:  SWAPF  7F,W
002D:  RETFIE
002E:  BCF    0A.3
002F:  BCF    0A.4
0030:  GOTO   09D
.................... #include "16f877a.h" 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
0031:  BCF    0A.0
0032:  BCF    0A.1
0033:  BCF    0A.2
0034:  ADDWF  02,F
0035:  RETLW  28
0036:  RETLW  0C
0037:  RETLW  01
0038:  RETLW  06
0039:  BCF    0A.0
003A:  BCF    0A.1
003B:  BCF    0A.2
003C:  ADDWF  02,F
003D:  RETLW  31
003E:  RETLW  32
003F:  RETLW  33
0040:  RETLW  46
0041:  RETLW  34
0042:  RETLW  35
0043:  RETLW  36
0044:  RETLW  45
0045:  RETLW  37
0046:  RETLW  38
0047:  RETLW  39
0048:  RETLW  44
0049:  RETLW  41
004A:  RETLW  30
004B:  RETLW  42
004C:  RETLW  43
004D:  BCF    0A.0
004E:  BCF    0A.1
004F:  BCF    0A.2
0050:  ADDWF  02,F
0051:  RETLW  31
0052:  RETLW  00
0053:  BCF    0A.0
0054:  BCF    0A.1
0055:  BCF    0A.2
0056:  ADDWF  02,F
0057:  RETLW  32
0058:  RETLW  00
*
010A:  DATA 50,39
010B:  DATA EF,33
010C:  DATA F2,30
010D:  DATA ED,30
010E:  DATA A0,24
010F:  DATA EE,34
0110:  DATA E3,34
0111:  DATA 61,32
0112:  DATA 6F,00
0113:  DATA 49,37
0114:  DATA 67,39
0115:  DATA E5,39
0116:  DATA 65,10
0117:  DATA 43,36
0118:  DATA 61,3B
0119:  DATA 65,05
011A:  DATA 00,00
011B:  DATA 41,36
011C:  DATA 61,39
011D:  DATA ED,30
011E:  DATA A0,30
011F:  DATA 63,3A
0120:  DATA 69,3B
0121:  DATA 61,00
*
01E0:  MOVF   0B,W
01E1:  MOVWF  3B
01E2:  BCF    0B.7
01E3:  BSF    03.5
01E4:  BSF    03.6
01E5:  BSF    0C.7
01E6:  BSF    0C.0
01E7:  NOP
01E8:  NOP
01E9:  BCF    03.5
01EA:  MOVF   0C,W
01EB:  ANDLW  7F
01EC:  BTFSC  03.2
01ED:  GOTO   227
01EE:  BCF    03.6
01EF:  MOVWF  3C
01F0:  BSF    03.6
01F1:  MOVF   0D,W
01F2:  BCF    03.6
01F3:  MOVWF  3D
01F4:  BSF    03.6
01F5:  MOVF   0F,W
01F6:  BCF    03.6
01F7:  MOVWF  3E
01F8:  MOVF   3C,W
01F9:  MOVWF  3F
01FA:  CALL   1B4
01FB:  MOVF   3D,W
01FC:  BSF    03.6
01FD:  MOVWF  0D
01FE:  BCF    03.6
01FF:  MOVF   3E,W
0200:  BSF    03.6
0201:  MOVWF  0F
0202:  BSF    03.5
0203:  BSF    0C.7
0204:  BSF    0C.0
0205:  NOP
0206:  NOP
0207:  BCF    03.5
0208:  RLF    0C,W
0209:  RLF    0E,W
020A:  ANDLW  7F
020B:  BTFSC  03.2
020C:  GOTO   227
020D:  BCF    03.6
020E:  MOVWF  3C
020F:  BSF    03.6
0210:  MOVF   0D,W
0211:  BCF    03.6
0212:  MOVWF  3D
0213:  BSF    03.6
0214:  MOVF   0F,W
0215:  BCF    03.6
0216:  MOVWF  3E
0217:  MOVF   3C,W
0218:  MOVWF  3F
0219:  CALL   1B4
021A:  MOVF   3D,W
021B:  BSF    03.6
021C:  MOVWF  0D
021D:  BCF    03.6
021E:  MOVF   3E,W
021F:  BSF    03.6
0220:  MOVWF  0F
0221:  INCF   0D,F
0222:  BTFSC  03.2
0223:  INCF   0F,F
0224:  BCF    03.6
0225:  GOTO   1E3
0226:  BSF    03.6
0227:  BCF    03.6
0228:  BTFSC  3B.7
0229:  BSF    0B.7
022A:  RETURN
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0059:  MOVF   4A,W
005A:  MOVWF  7A
005B:  MOVF   49,W
005C:  MOVWF  04
005D:  BCF    03.7
005E:  BTFSC  7A.0
005F:  BSF    03.7
0060:  MOVF   00,W
0061:  MOVWF  4D
0062:  MOVF   4C,W
0063:  MOVWF  7A
0064:  MOVF   4B,W
0065:  MOVWF  04
0066:  BCF    03.7
0067:  BTFSC  7A.0
0068:  BSF    03.7
0069:  MOVF   00,W
006A:  SUBWF  4D,W
006B:  BTFSS  03.2
006C:  GOTO   084
....................       if (*s1 == '\0') 
006D:  MOVF   4A,W
006E:  MOVWF  7A
006F:  MOVF   49,W
0070:  MOVWF  04
0071:  BCF    03.7
0072:  BTFSC  7A.0
0073:  BSF    03.7
0074:  MOVF   00,F
0075:  BTFSS  03.2
0076:  GOTO   07A
....................          return(0); 
0077:  MOVLW  00
0078:  MOVWF  78
0079:  GOTO   09C
007A:  MOVF   4A,W
007B:  MOVWF  7A
007C:  MOVF   49,W
007D:  INCF   49,F
007E:  BTFSC  03.2
007F:  INCF   4A,F
0080:  INCF   4B,F
0081:  BTFSC  03.2
0082:  INCF   4C,F
0083:  GOTO   059
....................    return((*s1 < *s2) ? -1: 1); 
0084:  MOVF   4A,W
0085:  MOVWF  7A
0086:  MOVF   49,W
0087:  MOVWF  04
0088:  BCF    03.7
0089:  BTFSC  4A.0
008A:  BSF    03.7
008B:  MOVF   00,W
008C:  MOVWF  4D
008D:  MOVF   4C,W
008E:  MOVWF  7A
008F:  MOVF   4B,W
0090:  MOVWF  04
0091:  BCF    03.7
0092:  BTFSC  4C.0
0093:  BSF    03.7
0094:  MOVF   00,W
0095:  SUBWF  4D,W
0096:  BTFSC  03.0
0097:  GOTO   09A
0098:  MOVLW  FF
0099:  GOTO   09B
009A:  MOVLW  01
009B:  MOVWF  78
009C:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0303:  BCF    03.5
0304:  CLRF   27
0305:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #fuses  NOWDT, HS, NOLVP, NOPROTECT, RESERVED 
.................... #use delay(clock=10000000) 
*
0139:  MOVLW  41
013A:  MOVWF  04
013B:  BCF    03.7
013C:  MOVF   00,W
013D:  BTFSC  03.2
013E:  GOTO   14D
013F:  MOVLW  03
0140:  MOVWF  78
0141:  CLRF   77
0142:  DECFSZ 77,F
0143:  GOTO   142
0144:  DECFSZ 78,F
0145:  GOTO   141
0146:  MOVLW  3C
0147:  MOVWF  77
0148:  DECFSZ 77,F
0149:  GOTO   148
014A:  GOTO   14B
014B:  DECFSZ 00,F
014C:  GOTO   13F
014D:  RETURN
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B2,rcv=PIN_B1,bits=8,STREAM=BLUE,errors) 
*
00C2:  BSF    03.5
00C3:  BSF    06.1
00C4:  BCF    03.5
00C5:  BTFSC  06.1
00C6:  GOTO   0C5
00C7:  MOVLW  08
00C8:  MOVWF  77
00C9:  CLRF   49
00CA:  BSF    77.7
00CB:  GOTO   0DA
00CC:  BCF    77.7
00CD:  GOTO   0DA
00CE:  BCF    03.0
00CF:  BTFSC  06.1
00D0:  BSF    03.0
00D1:  RRF    49,F
00D2:  BSF    77.6
00D3:  GOTO   0DA
00D4:  BCF    77.6
00D5:  DECFSZ 77,F
00D6:  GOTO   0CE
00D7:  MOVF   49,W
00D8:  MOVWF  78
00D9:  GOTO   0E6
00DA:  MOVLW  50
00DB:  BTFSC  77.7
00DC:  MOVLW  15
00DD:  MOVWF  78
00DE:  DECFSZ 78,F
00DF:  GOTO   0DE
00E0:  NOP
00E1:  BTFSC  77.7
00E2:  GOTO   0CC
00E3:  BTFSC  77.6
00E4:  GOTO   0D4
00E5:  GOTO   0CE
.................... #include "LCD.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
0168:  MOVLW  0F
0169:  BSF    03.5
016A:  ANDWF  08,W
016B:  IORLW  F0
016C:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
016D:  BCF    03.5
016E:  BSF    08.2
....................    delay_cycles(1); 
016F:  NOP
....................    lcd_output_enable(1); 
0170:  BSF    08.0
....................    delay_cycles(1); 
0171:  NOP
....................    high = lcd_read_nibble(); 
0172:  CALL   15C
0173:  MOVF   78,W
0174:  MOVWF  47
....................        
....................    lcd_output_enable(0); 
0175:  BCF    08.0
....................    delay_cycles(1); 
0176:  NOP
....................    lcd_output_enable(1); 
0177:  BSF    08.0
....................    delay_us(1); 
0178:  GOTO   179
....................    low = lcd_read_nibble(); 
0179:  CALL   15C
017A:  MOVF   78,W
017B:  MOVWF  46
....................        
....................    lcd_output_enable(0); 
017C:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
017D:  MOVLW  0F
017E:  BSF    03.5
017F:  ANDWF  08,W
0180:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0181:  BCF    03.5
0182:  SWAPF  47,W
0183:  MOVWF  77
0184:  MOVLW  F0
0185:  ANDWF  77,F
0186:  MOVF   77,W
0187:  IORWF  46,W
0188:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
015C:  MOVF   08,W
015D:  MOVWF  77
015E:  SWAPF  08,W
015F:  ANDLW  0F
0160:  MOVWF  78
....................   #endif 
0161:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
014E:  SWAPF  47,W
014F:  ANDLW  F0
0150:  MOVWF  77
0151:  MOVLW  0F
0152:  ANDWF  08,W
0153:  IORWF  77,W
0154:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
0155:  NOP
....................    lcd_output_enable(1); 
0156:  BSF    08.0
....................    delay_us(2); 
0157:  GOTO   158
0158:  GOTO   159
0159:  NOP
....................    lcd_output_enable(0); 
015A:  BCF    08.0
015B:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0162:  BSF    03.5
0163:  BCF    08.0
....................    lcd_rs_tris(); 
0164:  BCF    08.1
....................    lcd_rw_tris(); 
0165:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0166:  BCF    03.5
0167:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0189:  MOVF   78,W
018A:  MOVWF  46
018B:  BTFSC  46.7
018C:  GOTO   168
....................    lcd_output_rs(address); 
018D:  BTFSS  44.0
018E:  BCF    08.1
018F:  BTFSC  44.0
0190:  BSF    08.1
....................    delay_cycles(1); 
0191:  NOP
....................    lcd_output_rw(0); 
0192:  BCF    08.2
....................    delay_cycles(1); 
0193:  NOP
....................    lcd_output_enable(0); 
0194:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
0195:  SWAPF  45,W
0196:  MOVWF  46
0197:  MOVLW  0F
0198:  ANDWF  46,F
0199:  MOVF   46,W
019A:  MOVWF  47
019B:  CALL   14E
....................    lcd_send_nibble(n & 0xf); 
019C:  MOVF   45,W
019D:  ANDLW  0F
019E:  MOVWF  46
019F:  MOVWF  47
01A0:  CALL   14E
01A1:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
*
022B:  MOVLW  0F
022C:  BSF    03.5
022D:  ANDWF  08,W
022E:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
022F:  BCF    08.0
....................    lcd_rs_tris(); 
0230:  BCF    08.1
....................    lcd_rw_tris(); 
0231:  BCF    08.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
0232:  BCF    03.5
0233:  BCF    08.1
....................    lcd_output_rw(0); 
0234:  BCF    08.2
....................    lcd_output_enable(0); 
0235:  BCF    08.0
....................      
....................    delay_ms(15); 
0236:  MOVLW  0F
0237:  MOVWF  41
0238:  CALL   139
....................    for(i=1;i<=3;++i) 
0239:  MOVLW  01
023A:  MOVWF  3B
023B:  MOVF   3B,W
023C:  SUBLW  03
023D:  BTFSS  03.0
023E:  GOTO   247
....................    { 
....................        lcd_send_nibble(3); 
023F:  MOVLW  03
0240:  MOVWF  47
0241:  CALL   14E
....................        delay_ms(5); 
0242:  MOVLW  05
0243:  MOVWF  41
0244:  CALL   139
0245:  INCF   3B,F
0246:  GOTO   23B
....................    } 
....................     
....................    lcd_send_nibble(2); 
0247:  MOVLW  02
0248:  MOVWF  47
0249:  CALL   14E
....................    delay_ms(5); 
024A:  MOVLW  05
024B:  MOVWF  41
024C:  CALL   139
....................    for(i=0;i<=3;++i) 
024D:  CLRF   3B
024E:  MOVF   3B,W
024F:  SUBLW  03
0250:  BTFSS  03.0
0251:  GOTO   25B
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0252:  MOVF   3B,W
0253:  CALL   031
0254:  MOVWF  3C
0255:  CLRF   44
0256:  MOVF   3C,W
0257:  MOVWF  45
0258:  CALL   162
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0259:  INCF   3B,F
025A:  GOTO   24E
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
01A2:  DECFSZ 41,W
01A3:  GOTO   1A5
01A4:  GOTO   1A8
....................       address=LCD_LINE_TWO; 
01A5:  MOVLW  40
01A6:  MOVWF  42
01A7:  GOTO   1A9
....................    else 
....................       address=0; 
01A8:  CLRF   42
....................       
....................    address+=x-1; 
01A9:  MOVLW  01
01AA:  SUBWF  40,W
01AB:  ADDWF  42,F
....................    lcd_send_byte(0,0x80|address); 
01AC:  MOVF   42,W
01AD:  IORLW  80
01AE:  MOVWF  43
01AF:  CLRF   44
01B0:  MOVF   43,W
01B1:  MOVWF  45
01B2:  CALL   162
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01B3:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
01B4:  MOVF   3F,W
01B5:  XORLW  07
01B6:  BTFSC  03.2
01B7:  GOTO   1C2
01B8:  XORLW  0B
01B9:  BTFSC  03.2
01BA:  GOTO   1C7
01BB:  XORLW  06
01BC:  BTFSC  03.2
01BD:  GOTO   1CF
01BE:  XORLW  02
01BF:  BTFSC  03.2
01C0:  GOTO   1D5
01C1:  GOTO   1DA
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01C2:  MOVLW  01
01C3:  MOVWF  40
01C4:  MOVWF  41
01C5:  CALL   1A2
01C6:  GOTO   1DF
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
01C7:  CLRF   44
01C8:  MOVLW  01
01C9:  MOVWF  45
01CA:  CALL   162
....................                      delay_ms(2); 
01CB:  MOVLW  02
01CC:  MOVWF  41
01CD:  CALL   139
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
01CE:  GOTO   1DF
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01CF:  MOVLW  01
01D0:  MOVWF  40
01D1:  MOVLW  02
01D2:  MOVWF  41
01D3:  CALL   1A2
01D4:  GOTO   1DF
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
01D5:  CLRF   44
01D6:  MOVLW  10
01D7:  MOVWF  45
01D8:  CALL   162
01D9:  GOTO   1DF
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
01DA:  MOVLW  01
01DB:  MOVWF  44
01DC:  MOVF   3F,W
01DD:  MOVWF  45
01DE:  CALL   162
....................      #endif 
....................    } 
01DF:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "kbd2.c" 
.................... /*-------------------------------------------*\ 
....................  |	KBD2.C                                   | 
....................  
....................  |  Autor: Pedro M Jimnez                  | 
....................  
....................  |  (c) Microsystems Engineering (Bilbao)    | 
....................  
.................... \*-------------------------------------------*/ 
....................  
....................  
....................  
.................... // Funciones para la gestin del teclado de la Trainer PLUS. 
....................  
....................  
....................  
.................... // char kbd_getc( )   Devuelve el cdigo ASCII de la tecla pulsada. 
....................  
.................... //         Si no se puls ninguna, devuelve 0. 
....................  
....................  
....................  
....................  
....................  
.................... // Conexiones del teclado. 
....................  
.................... /*  
....................  
....................             RB0 RB1 RB2 RB3 
....................  
....................              ^   ^   ^   ^ 
....................  
....................              |   |   |   | 
....................  
....................            |---|---|---|---| 
....................  
....................   RB4 ---> | 1 | 2 | 3 | F | 
....................  
....................            |---|---|---|---| 
....................  
....................   RB5 ---> | 4 | 5 | 6 | E | 
....................  
....................            |---|---|---|---| 
....................  
....................   RB6 ---> | 7 | 8 | 9 | D | 
....................  
....................            |---|---|---|---| 
....................  
....................   RB7 ---> | A | 0 | B | C | 
....................  
....................            |---|---|---|---| 
....................  
.................... */ 
....................  
....................  
....................  
.................... // Caracteres ASCII asociados a cada tecla: 
....................  
.................... char const KEYS[4][4] = {{'1','2','3','F'} , 
....................  
....................                          {'4','5','6','E'} , 
....................  
....................                          {'7','8','9','D'} , 
....................  
....................                          {'A','0','B','C'} }; 
....................  
....................  
....................  
.................... #byte kbd_port_b = 6 
....................  
....................  
....................  
....................  
....................  
.................... char kbd_getc( ) 
*
0279:  CLRF   3B
....................  
.................... { 
....................  
....................   char tecla=0; 
....................  
....................   int f,c,t,i,j; 
....................  
....................  
....................  
....................   port_b_pullups(true); 
027A:  BSF    03.5
027B:  BCF    01.7
....................  
....................   set_tris_b(0b00001111); // RB7-RB4 salidas, RB3-RB0 entradas 
027C:  MOVLW  0F
027D:  MOVWF  06
....................  
....................  
....................  
....................   for(f=0x10, i=0; i<4; f<<=1, i++) 
027E:  MOVLW  10
027F:  BCF    03.5
0280:  MOVWF  3C
0281:  CLRF   3F
0282:  MOVF   3F,W
0283:  SUBLW  03
0284:  BTFSS  03.0
0285:  GOTO   2C2
....................  
....................   { 
....................  
....................     for(c=0x01, j=0; j<4; c<<=1, j++) 
0286:  MOVLW  01
0287:  MOVWF  3D
0288:  CLRF   40
0289:  MOVF   40,W
028A:  SUBLW  03
028B:  BTFSS  03.0
028C:  GOTO   2BB
....................  
....................     { 
....................  
....................       kbd_port_b = ~f; 
028D:  MOVF   3C,W
028E:  MOVWF  06
028F:  COMF   06,F
....................  
....................       delay_cycles(1); 
0290:  NOP
....................  
....................       t = kbd_port_b & 0x0F; 
0291:  MOVF   06,W
0292:  ANDLW  0F
0293:  MOVWF  3E
....................  
....................       t = ~(t | 0xF0 ); 
0294:  MOVF   3E,W
0295:  IORLW  F0
0296:  XORLW  FF
0297:  MOVWF  3E
....................  
....................       if(t == c) 
0298:  MOVF   3D,W
0299:  SUBWF  3E,W
029A:  BTFSS  03.2
029B:  GOTO   2B7
....................  
....................       { 
....................  
....................         delay_ms(20); 
029C:  MOVLW  14
029D:  MOVWF  41
029E:  CALL   139
....................  
....................         tecla=KEYS[i ][j ]; 
029F:  RLF    3F,W
02A0:  MOVWF  77
02A1:  RLF    77,F
02A2:  MOVLW  FC
02A3:  ANDWF  77,F
02A4:  MOVF   77,W
02A5:  ADDWF  40,W
02A6:  CALL   039
02A7:  MOVWF  78
02A8:  MOVWF  3B
....................  
....................         while(t==c) 
02A9:  MOVF   3D,W
02AA:  SUBWF  3E,W
02AB:  BTFSS  03.2
02AC:  GOTO   2B6
....................  
....................         { 
....................  
....................           restart_wdt( ); 
02AD:  CLRWDT
....................  
....................           t = kbd_port_b & 0x0F; 
02AE:  MOVF   06,W
02AF:  ANDLW  0F
02B0:  MOVWF  3E
....................  
....................           t = ~(t | 0xF0) ; 
02B1:  MOVF   3E,W
02B2:  IORLW  F0
02B3:  XORLW  FF
02B4:  MOVWF  3E
02B5:  GOTO   2A9
....................  
....................         } 
....................  
....................         break; 
02B6:  GOTO   2BB
....................  
....................       } 
02B7:  BCF    03.0
02B8:  RLF    3D,F
02B9:  INCF   40,F
02BA:  GOTO   289
....................  
....................     } 
....................  
....................     if(tecla) 
02BB:  MOVF   3B,F
02BC:  BTFSS  03.2
....................  
....................       break; 
02BD:  GOTO   2C2
02BE:  BCF    03.0
02BF:  RLF    3C,F
02C0:  INCF   3F,F
02C1:  GOTO   282
....................  
....................   } 
....................  
....................  
....................  
....................   port_b_pullups(false); 
02C2:  BSF    03.5
02C3:  BSF    01.7
....................  
....................   return tecla; 
02C4:  BCF    03.5
02C5:  MOVF   3B,W
02C6:  MOVWF  78
....................  
.................... } 
....................  
....................  
.................... // ************************************************************** 
.................... // Declaracion de las variables 
.................... char tecla[5]="\0"; 
*
0306:  CLRF   29
0307:  CLRF   2A
.................... char tecla_teclado; 
.................... int1 estado_clave=0; 
.................... char clave[4]={'1','3','5','7'}; 
0308:  MOVLW  31
0309:  MOVWF  30
030A:  MOVLW  33
030B:  MOVWF  31
030C:  MOVLW  35
030D:  MOVWF  32
030E:  MOVLW  37
030F:  MOVWF  33
.................... int1 clave_bluetooth = 0; 
.................... int pos_clave=0; 
....................  
.................... char boton1[3]="\0";  
0310:  CLRF   35
0311:  CLRF   36
.................... char boton2[3]="\0"; 
0312:  CLRF   38
0313:  CLRF   39
....................  
....................  
.................... //*************************************************************** 
....................  
.................... // ************************************************************** 
.................... // Declaracion de funciones 
....................    void Cargar_configuracion(); 
....................    void Configurar_interrupciones(); 
....................    void Ingreso_Clave(); 
.................... //*************************************************************** 
....................  
.................... // ************************************************************** 
.................... // Definicion de interrupciones 
.................... #INT_RDA 
.................... void  RDA_isr(void) { 
....................    boton1="1"; 
*
009D:  CLRF   49
009E:  CLRF   4A
009F:  MOVLW  35
00A0:  MOVWF  04
00A1:  BCF    03.7
00A2:  MOVF   49,W
00A3:  ADDWF  04,F
00A4:  MOVF   4A,W
00A5:  CALL   04D
00A6:  MOVWF  00
00A7:  IORLW  00
00A8:  BTFSC  03.2
00A9:  GOTO   0AD
00AA:  INCF   4A,F
00AB:  INCF   49,F
00AC:  GOTO   09F
....................    boton2="2"; 
00AD:  CLRF   49
00AE:  CLRF   4A
00AF:  MOVLW  38
00B0:  MOVWF  04
00B1:  BCF    03.7
00B2:  MOVF   49,W
00B3:  ADDWF  04,F
00B4:  MOVF   4A,W
00B5:  CALL   053
00B6:  MOVWF  00
00B7:  IORLW  00
00B8:  BTFSC  03.2
00B9:  GOTO   0BD
00BA:  INCF   4A,F
00BB:  INCF   49,F
00BC:  GOTO   0AF
....................   fgets(tecla,BLUE); //GUARDAMOS EN ENTRADA LO QUE HAY EN LA USART 
00BD:  MOVLW  29
00BE:  MOVWF  04
00BF:  BCF    03.7
00C0:  DECF   04,F
00C1:  INCF   04,F
*
00E6:  MOVF   78,W
00E7:  MOVWF  00
00E8:  MOVLW  0D
00E9:  SUBWF  00,W
00EA:  BTFSS  03.2
00EB:  GOTO   0C1
00EC:  CLRF   00
....................   if(strcmp(tecla,boton1)==0){ 
00ED:  CLRF   4A
00EE:  MOVLW  29
00EF:  MOVWF  49
00F0:  CLRF   4C
00F1:  MOVLW  35
00F2:  MOVWF  4B
00F3:  CALL   059
00F4:  MOVF   78,F
00F5:  BTFSS  03.2
00F6:  GOTO   0FA
....................       estado_clave = 1; 
00F7:  BSF    2F.0
....................       clave_bluetooth = 1; 
00F8:  BSF    2F.1
....................   }else if (strcmp(tecla,boton2)==0){ 
00F9:  GOTO   106
00FA:  CLRF   4A
00FB:  MOVLW  29
00FC:  MOVWF  49
00FD:  CLRF   4C
00FE:  MOVLW  38
00FF:  MOVWF  4B
0100:  CALL   059
0101:  MOVF   78,F
0102:  BTFSS  03.2
0103:  GOTO   106
....................       estado_clave = 0; 
0104:  BCF    2F.0
....................       clave_bluetooth = 0; 
0105:  BCF    2F.1
....................   } 
0106:  BCF    0C.5
0107:  BCF    0A.3
0108:  BCF    0A.4
0109:  GOTO   01D
.................... } 
.................... //*************************************************************** 
....................  
.................... // *************************************************************** 
.................... // Funcion Principal 
.................... void main() 
*
02F1:  MOVF   03,W
02F2:  ANDLW  1F
02F3:  MOVWF  03
02F4:  BSF    03.5
02F5:  BCF    06.2
02F6:  BCF    03.5
02F7:  BSF    06.2
02F8:  BCF    2F.0
02F9:  BCF    2F.1
02FA:  CLRF   34
02FB:  BSF    03.5
02FC:  BSF    1F.0
02FD:  BSF    1F.1
02FE:  BSF    1F.2
02FF:  BCF    1F.3
0300:  MOVLW  07
0301:  MOVWF  1C
0302:  BCF    03.7
.................... { 
....................    Configurar_interrupciones(); 
*
0314:  GOTO   122
....................    Cargar_configuracion(); 
0315:  GOTO   22B
....................     
....................    while(TRUE) 
....................    { 
....................       Ingreso_Clave(); 
0316:  GOTO   273
0317:  GOTO   316
....................    } 
....................  
.................... } 
.................... //**************************************************************** 
0318:  SLEEP
....................  
.................... // ************************************************************** 
.................... // Definicion de las funciones 
.................... void Cargar_configuracion(){ 
....................    lcd_init(); 
....................    printf(lcd_putc,"Programa Iniciado"); 
*
025B:  MOVLW  0A
025C:  BSF    03.6
025D:  MOVWF  0D
025E:  MOVLW  01
025F:  MOVWF  0F
0260:  BCF    03.6
0261:  CALL   1E0
....................    delay_ms(500); 
0262:  MOVLW  02
0263:  MOVWF  3B
0264:  MOVLW  FA
0265:  MOVWF  41
0266:  CALL   139
0267:  DECFSZ 3B,F
0268:  GOTO   264
....................    printf(lcd_putc,"Ingrese Clave\n"); 
0269:  MOVLW  13
026A:  BSF    03.6
026B:  MOVWF  0D
026C:  MOVLW  01
026D:  MOVWF  0F
026E:  BCF    03.6
026F:  CALL   1E0
0270:  BCF    0A.3
0271:  BCF    0A.4
0272:  GOTO   316 (RETURN)
.................... } 
.................... void Configurar_interrupciones(){ 
....................    setup_comparator(NC_NC_NC_NC);//DESACTIVAMOS COMPARADORES 
*
0122:  MOVLW  07
0123:  BSF    03.5
0124:  MOVWF  1C
0125:  MOVF   05,W
0126:  MOVWF  05
0127:  MOVLW  07
0128:  MOVWF  77
0129:  DECFSZ 77,F
012A:  GOTO   129
012B:  GOTO   12C
012C:  NOP
012D:  MOVF   1C,W
012E:  BCF    03.5
012F:  BCF    0D.6
....................    setup_vref(FALSE); 
0130:  BSF    03.5
0131:  CLRF   1D
....................    enable_interrupts(INT_RDA); //POR PUERTO DE COMUNICACIONES  
0132:  BSF    0C.5
....................    enable_interrupts(GLOBAL);  //E INTERRUPCIONES GLOBALES 
0133:  MOVLW  C0
0134:  BCF    03.5
0135:  IORWF  0B,F
0136:  BCF    0A.3
0137:  BCF    0A.4
0138:  GOTO   315 (RETURN)
.................... } 
.................... void Ingreso_Clave(){ 
....................    pos_clave = 0; 
*
0273:  CLRF   34
....................    estado_clave = 1; 
0274:  BSF    2F.0
....................   while (pos_clave<=4){ 
0275:  MOVF   34,W
0276:  SUBLW  04
0277:  BTFSS  03.0
0278:  GOTO   2D8
....................     tecla_teclado = kbd_getc(); 
*
02C7:  MOVF   78,W
02C8:  MOVWF  2E
....................     if (tecla != 0 && clave_bluetooth==0){ 
02C9:  BTFSC  2F.1
02CA:  GOTO   2D7
....................        //printf(lcd_putc,"*"); 
....................        if (tecla != clave[pos_clave]){ 
02CB:  MOVLW  30
02CC:  ADDWF  34,W
02CD:  MOVWF  04
02CE:  BCF    03.7
02CF:  MOVF   00,W
02D0:  SUBLW  29
02D1:  BTFSS  03.2
02D2:  GOTO   2D5
02D3:  XORLW  00
02D4:  BTFSS  03.2
....................           estado_clave = 0; 
02D5:  BCF    2F.0
....................           //printf(lcd_putc,"*"); 
....................        } 
....................        pos_clave++; 
02D6:  INCF   34,F
....................     } 
02D7:  GOTO   275
....................   } 
....................   if (estado_clave == 1){ 
02D8:  BTFSS  2F.0
02D9:  GOTO   2EE
....................       lcd_putc('\f'); 
02DA:  MOVLW  0C
02DB:  MOVWF  3F
02DC:  CALL   1B4
....................       printf(lcd_putc,"Alarma activa"); 
02DD:  MOVLW  1B
02DE:  BSF    03.6
02DF:  MOVWF  0D
02E0:  MOVLW  01
02E1:  MOVWF  0F
02E2:  BCF    03.6
02E3:  CALL   1E0
....................       delay_ms(500); 
02E4:  MOVLW  02
02E5:  MOVWF  3B
02E6:  MOVLW  FA
02E7:  MOVWF  41
02E8:  CALL   139
02E9:  DECFSZ 3B,F
02EA:  GOTO   2E6
....................       lcd_putc('\f'); 
02EB:  MOVLW  0C
02EC:  MOVWF  3F
02ED:  CALL   1B4
....................   } 
02EE:  BCF    0A.3
02EF:  BCF    0A.4
02F0:  GOTO   317 (RETURN)
.................... } 
.................... //*************************************************************** 

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
